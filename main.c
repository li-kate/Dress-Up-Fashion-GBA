#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "player.h" 
#include "character.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/title_screen.h"
#include "images/floorImage.h"
#include "images/curtains.h"
#include "images/runway.h"
#include "images/camera.h"

#include "images/enter1.h"
#include "images/enter2.h"
#include "images/enter3.h"
#include "images/enter4.h"
#include "images/enter5.h"

extern int numPartOptions;


/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // initial application state
  enum gba_state state = START;
  drawFullScreenImageDMA(title_screen);

  // player and character
  Player player;
  initPlayer(&player);
  Character character;
  initCharacter(&character);

  // photos
  int photoCounter = 0;
  char counterText[11];
  const char *congratsMessages[] = {
    "WOW!",
    "AWESOME OUTFIT!",
    "STYLISH!",
    "FABULOUS!",
    "GORGEOUS!",
    "AMAZING!",
    "PERFECT!",
    "FASHION ICON!",
    "LOVELY!",
    "STUNNING!"
  };
  int currentMessageIndex = 0;


  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    //if (reset button pressed) {drawfullscreenimg and reset variables}
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START:
        ;
        static int animFrame = 0; // static bc we want to keep the value bw frames
        static int animCounter = 0;
        const int ANIM_SPEED = 10;
        int animWidth = ENTER1_WIDTH;
        int animHeight = ENTER1_HEIGHT;
        int animX = (WIDTH - animWidth) / 2;
        int animY = (HEIGHT - animHeight) / 2;
      
        switch(animFrame) {
            case 0: drawImageDMA(animY, animX, animWidth, animHeight, enter1); break;
            case 1: drawImageDMA(animY, animX, animWidth, animHeight, enter2); break;
            case 2: drawImageDMA(animY, animX, animWidth, animHeight, enter3); break;
            case 3: drawImageDMA(animY, animX, animWidth, animHeight, enter4); break;
            case 4: drawImageDMA(animY, animX, animWidth, animHeight, enter5); break;
        }
        
        // Press enter at center
        drawRectDMA(HEIGHT/2 - 5, (WIDTH - 70) / 2, 70, 10, PINK);
        drawCenteredString(HEIGHT/2 - 5, 0, WIDTH, 10, "PRESS ENTER", WHITE);

        // Update animation frame
        animCounter++;
        if (animCounter >= ANIM_SPEED) {
            animCounter = 0;
            animFrame++;
            if (animFrame > 4) animFrame = 0;
        }
        
        // button to dress up
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          drawRectDMA(0, CURTAINS_WIDTH, WIDTH - CURTAINS_WIDTH, HEIGHT - FLOOR_HEIGHT, WHITE); // Draw white background
          drawImageDMA(HEIGHT - FLOOR_HEIGHT, 0, WIDTH, FLOOR_HEIGHT, floorImage); // Draw floor
          drawPartOptions(); // Draw part options
          drawImageDMA(0, 0, CURTAINS_WIDTH, CURTAINS_HEIGHT, curtains); // Draw curtains
          drawCharacter(&character, CHARACTER_START_X, CHARACTER_START_Y); // Draw character
          state = PLAY;
        }
        break;
      
      case PLAY:
          // erase the previous player position
          if ((player.prevX != player.x || player.prevY != player.y) &&
          player.prevX >= CURTAINS_WIDTH + WING_WIDTH && 
          player.prevX + player.width + WING_WIDTH <= WIDTH &&
          player.prevY >= 0 && 
          player.prevY + player.height <= HEIGHT - FLOOR_HEIGHT) {
            int eraseWidth = player.width + 2*WING_WIDTH;
            int eraseX = player.prevX - WING_WIDTH;
            drawRectDMA(player.prevY, eraseX, eraseWidth, player.height, WHITE);
            redrawPartsUnderPlayer(&player);
          }
          
          // Update and draw player
          updatePlayer(&player, currentButtons);
          int collidedPart = checkPartSelection(&player);
          
          // Part selection functionality
          if (collidedPart >= 0) {
              if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) { // SHIFT Z
                  selectPart(&character, &partOptions[collidedPart]);
                  drawCharacter(&character, CHARACTER_START_X, CHARACTER_START_Y);
              }
          }
          
          drawPlayer(&player);
          
          // Return to title screen
          if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            drawFullScreenImageDMA(title_screen);
            state = START;
            initPlayer(&player);
          }
          // Go to win screen
          if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) { // ENTER
            drawFullScreenImageDMA(runway);
            int centerX = (WIDTH - SHIRT_WIDTH) / 2;
            int centerY = (HEIGHT - (HEAD_HEIGHT + SHIRT_HEIGHT + PANTS_HEIGHT)) / 2;
            
            // Draw character at center
            drawCharacter(&character, centerX, centerY);
            state = WIN;

            // Add camera
            drawImageDMA(0, 0, CAMERA_WIDTH, CAMERA_HEIGHT, camera);

            // Draw photo counter
            sprintf(counterText, "%d", photoCounter);
            drawString(10, 40, counterText, WHITE);
          }
        break;
      case WIN:
        // Display  message every 10 photos
        if (photoCounter > 0 && photoCounter % 10 == 0) {
          currentMessageIndex = (photoCounter / 10 - 1) % 10;
          
          // Clear message area for new message
          int messageY = HEIGHT - 30;
          drawRectDMA(messageY, WIDTH/2 - 50, 100, 20, WHITE);
          
          // Draw new message
          drawCenteredString(messageY, WIDTH/2 - 80, 160, 20, 
            (char *)congratsMessages[currentMessageIndex], PINK);
        }
        
        // Increment counter when B/Z is pressed
        if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
            photoCounter++;
            drawRectDMA(10, 40, 40, 10, BLACK);
            sprintf(counterText, "%d", photoCounter);
            drawString(10, 40, counterText, WHITE);
        }

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(title_screen);
          state = START;
          photoCounter = 0;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
