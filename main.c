#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "player.h" 
#include "character.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/title_screen.h"
#include "images/floorImage.h"
#include "images/curtains.h"


/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  drawFullScreenImageDMA(title_screen);

  // Initialize player
  Player player;
  initPlayer(&player);
  Character character;
  initCharacter(&character);

  int leftWingX = player.prevX - WING_WIDTH;
  int rightWingX = player.prevX + player.width;

  // Bounds partsBounds; // Initialize bounding box for part options


  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    //if (reset button pressed) {drawfullscreenimg and reset variables}
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START:
        ;
        
        // Start Button
        int btnWidth = 90;
        int btnHeight = 25;
        int btnX = (WIDTH - btnWidth) / 2;
        int btnY = (HEIGHT - btnHeight) / 2;

        u16 btnColor = PINK;
        drawRectDMA(btnY, btnX, btnWidth, btnHeight, btnColor);

        // Button text
        drawCenteredString(btnY + btnHeight/2 - 4, btnX, btnWidth, 8, "PRESS ENTER", WHITE);
        
        // Button functionality
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          drawRectDMA(0, CURTAINS_WIDTH, WIDTH - CURTAINS_WIDTH, HEIGHT - FLOOR_HEIGHT, WHITE); // Draw white background
          drawImageDMA(0, 0, CURTAINS_WIDTH, CURTAINS_HEIGHT, curtains); // Draw curtains
          drawImageDMA(HEIGHT - FLOOR_HEIGHT, 0, WIDTH, FLOOR_HEIGHT, floorImage); // Draw floor
          drawCharacter(&character); // Draw character
          drawPartOptions(); // Draw part options
          state = PLAY;
        }
        break;
      
      case PLAY:
        // background - not floor
        // Get parts bounding area
        // partsBounds = getPartsBounds();
        
        // // Draw white background in 4 rectangles around the parts area
        // // 1. Top section (above parts)
        // if (partsBounds.y1 > CURTAINS_WIDTH) {
        //     drawRectDMA(0, CURTAINS_WIDTH, 
        //               WIDTH - CURTAINS_WIDTH, partsBounds.y1 - CURTAINS_WIDTH, 
        //               WHITE);
        // }
        
        // // 2. Left section (left of parts)
        // if (partsBounds.x1 > CURTAINS_WIDTH) {
        //     drawRectDMA(partsBounds.y1, CURTAINS_WIDTH,
        //               partsBounds.x1 - CURTAINS_WIDTH, partsBounds.y2 - partsBounds.y1,
        //               WHITE);
        // }
        
        // // 3. Right section (right of parts)
        // if (partsBounds.x2 < WIDTH) {
        //     drawRectDMA(partsBounds.y1, partsBounds.x2,
        //               WIDTH - partsBounds.x2, partsBounds.y2 - partsBounds.y1,
        //               WHITE);
        // }
        
        // // 4. Bottom section (below parts)
        // if (partsBounds.y2 < HEIGHT - FLOOR_HEIGHT) {
        //     drawRectDMA(partsBounds.y2, CURTAINS_WIDTH,
        //               WIDTH - CURTAINS_WIDTH, (HEIGHT - FLOOR_HEIGHT) - partsBounds.y2,
        //               WHITE);
        // }
        leftWingX = player.prevX - WING_WIDTH;
        rightWingX = player.prevX + player.width;
        
        // Draw white background where player was (main body + wings)
        // 1. Left wing
        drawRectDMA(player.prevY + (player.height - WING_HEIGHT)/2, 
                   leftWingX,
                   WING_WIDTH, WING_HEIGHT,
                   WHITE);
        
        // 2. Main body
        drawRectDMA(player.prevY,
                   player.prevX,
                   player.width, player.height,
                   WHITE);
        
        // 3. Right wing
        drawRectDMA(player.prevY + (player.height - WING_HEIGHT)/2,
                   rightWingX,
                   WING_WIDTH, WING_HEIGHT,
                   WHITE);

        // drawRectDMA(player.prevY, player.prevX - WING_WIDTH, player.width + WING_WIDTH, player.height, WHITE);
        
        // Update and draw player
        updatePlayer(&player, currentButtons);
        int collidedPart = checkPartSelection(&player);
    
        // Only draw the collided part (if any)
        if (collidedPart >= 0) {
          drawSinglePartOption(collidedPart);
          // Handle part selection
          if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
            PartOption* selected = getPartAtPosition(player.x, player.y);
            if (selected) {
                selectPart(&character, selected);
                drawCharacter(&character);
            }
          }
        }
        drawPlayer(&player);
        
        // Return to title screen
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            drawFullScreenImageDMA(title_screen);
            state = START;
            initPlayer(&player); // Reset player position
        }
        break;
      case WIN:

        // state = ?
        break;
      case LOSE:

        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
